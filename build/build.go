package build

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"
	"text/template"
	"time"

	"github.com/twharmon/forge/config"
	"github.com/twharmon/forge/parser"
	"github.com/twharmon/forge/utils"

	"gopkg.in/yaml.v3"
)

func All() error {
	start := time.Now()
	cfg, err := config.Get()
	if err != nil {
		return fmt.Errorf("build.All: %w", err)
	}
	prsr := parser.New(parser.Config{
		Extensions: cfg.Markdown.Extensions,
		Minify:     !cfg.Forge.Debug,
	})
	if err := os.RemoveAll("build"); err != nil {
		return fmt.Errorf("build.All: %w", err)
	}
	if err := utils.Mkdir("build"); err != nil {
		return fmt.Errorf("build.All: %w", err)
	}
	if cfg.Forge.Debug {
		if err := utils.WriteFile(path.Join("build", "debug.js"), debugJS); err != nil {
			return fmt.Errorf("build.All: %w", err)
		}
	}
	if err := prsr.CopyDirectory("public", "build"); err != nil {
		return err
	}
	if err := prsr.CopyDirectory(path.Join("themes", cfg.Theme.Name, "public"), "build"); err != nil {
		return err
	}
	t := template.New("base.html")
	t, err = t.ParseGlob(path.Join("themes", cfg.Theme.Name, "layouts/*"))
	if err != nil {
		return fmt.Errorf("build.All: %w", err)
	}
	if err := dir(t, cfg, prsr, "content"); err != nil {
		return err
	}
	fmt.Printf("build completed in %s\n\n", time.Since(start).Round(time.Microsecond*100))
	return nil
}

func dir(t *template.Template, cfg *config.Config, prsr *parser.Parser, dirName string) error {
	fis, err := ioutil.ReadDir(dirName)
	if err != nil {
		return fmt.Errorf("build.dir: %w", err)
	}
	for _, fi := range fis {
		if fi.IsDir() {
			if err := dir(t, cfg, prsr, path.Join(dirName, fi.Name())); err != nil {
				return fmt.Errorf("build.dir: %w", err)
			}
			continue
		}
		if err := page(t, cfg, prsr, path.Join(dirName, fi.Name())); err != nil {
			return fmt.Errorf("build.dir: %w", err)
		}
	}
	return nil
}

func page(t *template.Template, cfg *config.Config, prsr *parser.Parser, page string) error {
	pagePath := "build/" + strings.TrimPrefix(page, "content/")
	pageDir, pageName := path.Split(pagePath)
	if !strings.HasPrefix(pageName, "index.") {
		nameParts := strings.Split(pageName, ".")
		pageDir = path.Join(pageDir, nameParts[0])
		pageName = "index.html"
	}
	if err := utils.Mkdir(pageDir); err != nil {
		return fmt.Errorf("build.page: %w", err)
	}
	f, err := os.Create(path.Join(pageDir, strings.ReplaceAll(pageName, ".md", ".html")))
	if err != nil {
		return fmt.Errorf("build.page: %w", err)
	}
	pathname := strings.TrimPrefix(pageDir, "build")
	t, err = t.Clone()
	if err != nil {
		return fmt.Errorf("build.page: %w", err)
	}
	pageParams := make(map[string]interface{})
	if strings.HasSuffix(page, ".md") {
		b, err := ioutil.ReadFile(page)
		if err != nil {
			return fmt.Errorf("build.page: %w", err)
		}
		parts := bytes.SplitN(b, []byte("---"), 3)
		if len(parts) != 3 && len(parts) != 1 {
			return fmt.Errorf(`build.page: maleformed content; front matter must be surrounded by "---"`)
		}
		body := parts[0]
		if len(parts) == 3 {
			body = parts[2]
			if err := yaml.Unmarshal(parts[1], &pageParams); err != nil {
				return fmt.Errorf("build.page: %w", err)
			}
		}
		var buf bytes.Buffer
		if err := prsr.Markdown(body, &buf); err != nil {
			return fmt.Errorf("build.page: %w", err)
		}
		t, err = t.Parse(fmt.Sprintf(`{{ define "body" }}%s{{ end }}`, buf.String()))
		if err != nil {
			return fmt.Errorf("build.page: %w", err)
		}
	} else if strings.HasSuffix(page, ".html") {
		t, err = t.ParseFiles(page)
		if err != nil {
			return fmt.Errorf("build.page: %w", err)
		}
	} else {
		return fmt.Errorf("build.page: invalid content: %s", page)
	}
	data := map[string]interface{}{
		"Theme":    cfg.Theme.Params,
		"Page":     pageParams,
		"Forge":    cfg.Forge,
		"Pathname": pathname,
	}
	if cfg.Forge.Debug {
		if err := t.Execute(f, data); err != nil {
			return fmt.Errorf("build.page: %w", err)
		}
	} else {
		var buf bytes.Buffer
		if err := t.Execute(&buf, data); err != nil {
			return fmt.Errorf("build.page: %w", err)
		}
		if err := prsr.Minify("text/html", f, &buf); err != nil {
			return fmt.Errorf("build.page: %w", err)
		}
	}
	return nil
}

var debugJS = []byte(`// generated by Forge for hot reloading
new WebSocket('ws://' + window.location.host + '/hot').onmessage = e => e.data === 'reload' && window.location.reload()
`)
